using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators;

[Generator]
public class SimpleDtoGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(i =>i.AddSource("Attributes/GenerateDtoAttribute.g.cs", SourceText.From("""
            // <auto-generated/>
            using System;
            
            namespace Generators;

            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false)]
            public class GenerateDtoAttribute : Attribute
            {
            }
            """, Encoding.UTF8)));
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Recherche des classes avec l'attribut GenerateDto
        var classesWithAttributeGenerateDto = context.Compilation.SyntaxTrees
            .SelectMany(syntaxTree => syntaxTree.GetRoot().DescendantNodes())
            .OfType<BaseTypeDeclarationSyntax>()
            .Where(
                typeDeclarationSyntax => typeDeclarationSyntax.AttributeLists.Any(
                    attributeListSyntax => attributeListSyntax.Attributes.Any(
                        attributeSyntax => attributeSyntax.Name.ToString() == "GenerateDto")));

        foreach (var classWithAttributeGenerateDto in classesWithAttributeGenerateDto)
        {
            // Récupération des using
            var usingDirectives = classWithAttributeGenerateDto.SyntaxTree.GetRoot()
                .DescendantNodesAndSelf()
                .OfType<UsingDirectiveSyntax>()
                .Select(usingDirective => usingDirective.ToFullString());

            var sourceBuilder = new StringBuilder().AppendLine("// <auto-generated />");
            foreach (var usingDirective in usingDirectives)
            {
                sourceBuilder.AppendLine(usingDirective);
            }

            // Récupération du namespace et du nom de la classe
            var semanticModel = context.Compilation.GetSemanticModel(classWithAttributeGenerateDto.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classWithAttributeGenerateDto);
            var namespaceName = classSymbol?.ContainingNamespace.ToDisplayString() ?? "Generators";
            var className = classWithAttributeGenerateDto.Identifier.Text;
            var dtoClassName = $"{className}Dto";

            sourceBuilder.AppendLine($@"#nullable enable
namespace {namespaceName};

public record {dtoClassName}
{{");
            
            // Récupération des propriétés
            var properties = classWithAttributeGenerateDto switch
            {
                ClassDeclarationSyntax classDeclaration => classDeclaration.Members.OfType<PropertyDeclarationSyntax>()
                                                                           .Select(p => (p.Identifier.Text, p.Type.ToString())),
                
                RecordDeclarationSyntax recordDeclaration => recordDeclaration.ParameterList?.Parameters
                                                                              .Select(p => (p.Identifier.Text, p.Type.ToString())),
                
                _ => throw new InvalidOperationException("Unsupported type declaration.")
            };
            
            foreach (var (propertyName, propertyType) in properties)
            {
                sourceBuilder.AppendLine($"    public {propertyType} {propertyName} {{ get; init; }}");
            }

            sourceBuilder.AppendLine("}");

            context.AddSource($"Models/{dtoClassName}.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
        }
    }
}