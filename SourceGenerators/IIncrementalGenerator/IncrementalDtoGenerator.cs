using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators.IIncrementalGenerator;

[Generator]
public class IncrementalDtoGenerator : Microsoft.CodeAnalysis.IIncrementalGenerator
{
    private const string Namespace = "Generators";
    private const string AttributeName = "IncrementalGenerateDtoAttribute";
    private const string AttributeSourceCode =
        $$"""
          // <auto-generated/>
          namespace {{Namespace}};

          [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false)]
          public class {{AttributeName}} : System.Attribute
          {
          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {        
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("Attributes/IncrementalGenerateDtoAttribute.g.cs", SourceText.From(AttributeSourceCode, Encoding.UTF8)));
        
        var provider = context.SyntaxProvider
          .CreateSyntaxProvider(
              (s, _) => s is RecordDeclarationSyntax or ClassDeclarationSyntax,
              (ctx, _) => GetDeclarationForSourceGen(ctx))
          .Where(t => t.AttributeFound)
          .Select((t, _) => t.Node);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()), (ctx, t) => GenerateCode(ctx, t.Left, t.Right.OfType<TypeDeclarationSyntax>()));
    }

    private static (SyntaxNode Node, Boolean AttributeFound) GetDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        var currentNode = context.Node;
        var attributeLists = currentNode switch
        {
            ClassDeclarationSyntax classDeclaration => classDeclaration.AttributeLists,
            RecordDeclarationSyntax recordDeclaration => recordDeclaration.AttributeLists,
            _ => default
        };

        var attributeFound = attributeLists.Any(attributeList => 
            attributeList.Attributes.Any(attributeSyntax =>
                IsTargetAttribute(attributeSyntax, context.SemanticModel)));

        return (currentNode, attributeFound);
    }

    private static bool IsTargetAttribute(AttributeSyntax attributeSyntax, SemanticModel semanticModel)
    {
        if (semanticModel.GetSymbolInfo(attributeSyntax).Symbol is IMethodSymbol attributeSymbol)
        {
            return attributeSymbol.ContainingType.ToDisplayString() == $"{Namespace}.{AttributeName}";
        }

        return false;
    }
    
   private static void GenerateCode(SourceProductionContext context, Compilation compilation, IEnumerable<TypeDeclarationSyntax> declarations)
    {
        foreach (var declarationSyntax in declarations)
        {
            var semanticModel = compilation.GetSemanticModel(declarationSyntax.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(declarationSyntax) is not INamedTypeSymbol symbol) continue;

            var namespaceName = symbol.ContainingNamespace.ToDisplayString();
            var domainName = declarationSyntax.Identifier.Text;
            var dtoName = domainName + "Dto";

            var source = new StringBuilder(
                $$"""
                // <auto-generated/>
                #nullable enable
                namespace {{namespaceName}};
                    
                public sealed record {{dtoName}}({{GenerateProperties(declarationSyntax)}})
                {
                """);

            GenerateMapping(declarationSyntax, dtoName, domainName, source);
            source.AppendLine("}");
            
            context.AddSource($"Models/{dtoName}.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
        }
    }

    private static void GenerateMapping(TypeDeclarationSyntax declarationSyntax, string dtoName, string domainName, StringBuilder source)
    {
        var parameters = declarationSyntax switch
        {
            RecordDeclarationSyntax record => record.ParameterList?.Parameters,
            ClassDeclarationSyntax @class => @class.Members.OfType<ConstructorDeclarationSyntax>().FirstOrDefault()?.ParameterList.Parameters,
            _ => Enumerable.Empty<ParameterSyntax>()
        };

        var parameterSyntaxes = parameters?.ToList();
        if (parameterSyntaxes != null && !parameterSyntaxes.Any())
            return;

        AppendExplicitOperator(domainName, dtoName, source, parameterSyntaxes, addBreakLine: true);
        AppendExplicitOperator(dtoName, domainName, source, parameterSyntaxes);
    }

    private static void AppendExplicitOperator(string fromType, string toType, StringBuilder source, IEnumerable<ParameterSyntax> parameters, bool addBreakLine = false)
    {
        if (addBreakLine) source.AppendLine();

        var parameterMappings = parameters.Select(p => $"model.{p.Identifier.ValueText.ToPascalCase()}");
        source.AppendLine($"    public static explicit operator {toType}({fromType} model) => new({string.Join(", ", parameterMappings)});");
    }

    private static string GenerateProperties(TypeDeclarationSyntax declarationSyntax)
    {
        IEnumerable<(string Name, string Type)> properties = declarationSyntax switch
        {
            RecordDeclarationSyntax record when record.ParameterList != null => 
                record.ParameterList.Parameters.Select(p => (p.Identifier.Text, p.Type?.ToString() ?? "Object")),
            
            ClassDeclarationSyntax @class => 
                @class.Members.OfType<PropertyDeclarationSyntax>().Select(p => (p.Identifier.Text, p.Type.ToString())),
            
            _ => Enumerable.Empty<(string Name, string Type)>()
        };

        return string.Join(", ", properties.Select(p => $"{p.Type} {p.Name}"));
    }
}